<% include about-header %>

        <% include about-accordion-toggle %>

        <div id="about-main-text" class="text-block ui-accordion-top">
            
            <h3>The Basics</h3>
            <div id="architecture-basics">
                <p>
                    This application is written entirely in <strong>JavaScript</strong>, using <strong>Node.js</strong> and <strong>Express</strong> on the server side. I’ve always enjoyed the good parts of JavaScript; and Node.js had been calling to me for quite some time. It’s ultra-light, ultra-fast, and the non-blocking/async nature does not carry a huge learning curve (in my opinion). 
                </p>
                <p>
                    All apps need a place to live. For this application I went with a <strong>Linux</strong> instance of <strong>Amazon EC2</strong>, with a corresponding <strong>S3</strong> instance for data storage. So far I have no regrets with this choice. The admin interface, including port management is pretty straightforward.
                </p>
                <p>
                    I also wanted to run a web server/proxy so that I could run multiple Node.js instances with a reverse proxy handling directions. For this I went with <strong>NGINX</strong> and I must say I have been impressed. Setting up reverse proxies has never been easier.
                </p>
                <p>
                    One last consideration was keeping the Node.js service running on the server. A quick implementation of the <strong>Forever</strong> service offered exactly what I was looking for. It also includes a fair amount of fault-tolerance and auto-recovery that can be additionally configured.
                </p>
            </div>

            <h3>The MEAN Stack</h3>
            <div id="architecture-mean">
                <p>
                    Building the server side on JavaScript using Node.js has the obvious advantages of carrying a single language throughout the stack. However, we still need a web framework, a database, and a front-end. The MEAN stack was a fairly obvious choice for this: MongoDB, Express.js, Angular.js, along with Node. 
                </p>

                <ul>
                    <li>
                        <strong>MongoDB</strong><br />
                        I've worked a lot in the reporting and RDBMS realm, so MongoDB is <em>very</em> intriguing. It’s a document-based data store that uses very little overhead, completely ignores tradtional row-based “schemas”, and stores data in JSON-like collections. For JavaScript developers it offers an intuitive approach and reinforces the full JavaScript stack.
                    </li>
                    <li>
                        <strong>Express.js</strong><br />
                        Express is an unsung hero in the MEAN stack. For a web app like this one, it does a lot of heavy lifting and interaction with Node. It is an excellent abstraction layer for the request-response paradigm.
                    </li>
                    <li>
                        <strong>Angular.js</strong><br />
                        .... I actually didn't use this... yet. It’s very robust and powerful, essentially letting you build out a front-end framework specific to your app. I’m using it on some newer projects and I'm VERY excited about it. For this app, I just went with <strong>EJS</strong> - a basic template engine (making this a “MEEN” stack). Angular is what I’m focused on moving forward - and I can still use template engines like EJS or Swig inside of an Angular front end.
                    </li>
                </ul>

            </div>

            <h3>MVC Pattern</h3>
            <div id="architecture-mvc">
                <p>
                    MVC stands for model-view-controller. It is a sweeping trend in application design that, among other things, allows for a high degree of &quot;separation of concerns.&quot; There are several MVx patterns, but MVC is a good starting point. It is a pattern that can be used with server-side APIs and front-end frameworks alike.
                </p>
                <p>
                    The <em>model</em> is your data, the <em>view</em> is your interface, and the <em>controller</em> is your application logic. I enjoy how it lets me work on a single part of the architecture at a time. Also, maintenance and refactoring tasks are significantly reduced with a pattern like MVC. One of the best things about it from a JavaScript perspective is that it taught me how to separate my code in to more effective modules.
                </p>
            </div>

            <h3>Profile Management and Security</h3>
            <div id="architecture-profile">
                <p>
                    Anytime you talk about user profiles and logins you have to have a way to manage authentication and authorization. As you may have noticed, this app gives you 2 complete choices: a locally-managed login, as well as logins using social network authentication. <strong>Passport.js</strong> was used in combination with <strong>OAuth</strong> to provide that functionality. This also required configuration and token exchange via the various <strong>social APIs</strong> (LinkedIn, Google, Facebook, etc). You can also link your social logins to your local account and vice versa, giving the user added convenience if they are already logged in to their social accounts.
                </p>
            </div>

            <h3>Other Helpful Utilities</h3>
            <div id="architecture-utilities">
                <p>
                    Other libraries, frameworks, and APIs I used to speed things up:
                </p>
                <ul>
                    <li>
                        <strong>Mongoose</strong><br />
                        A driver for MongoDB that provides quite a bit of abstraction when you want it, while still not interfering with most native MongoDB commands.
                    </li>
                    <li>
                        <strong>node-promise</strong><br />
                        This was useful for some of my MongoDB queries from Node/Express. Since Node is non-blocking async, promises were a clean way to keep things things pipelined using the single-threaded environment. I went with this because it was Node-specific; however a library like Q would have also worked.
                    </li>
                    <li>
                        <strong>MD5 Hasher</strong><br />
                        This NPM package came in very handy for quickly hashing emails for Gravatar (bcrypt with Blowfish is still used for passwords).
                    </li>
                    <li>
                        <strong>Twitter Bootstrap</strong><br />
                        This is an HTML/CSS/JavaScript framework that is extremely valuable when wiring up quick and attractive front-ends. The learning curve is minimal and the grid layout suits most applications.
                    </li>
                    <li>
                        <strong>jQuery</strong><br />
                        A well-known micro-framework for JavaScript and a favorite of many front-end developers. I used it only on the front-end for this project, though I am anxious to see how it can help me on the server-side in the future.
                    </li>
                    <li>
                        <strong>Gravatar</strong><br />
                        A globally-recognized-avatar API that lets this app display profile images. It doesn’t force the user to maintain a separate avatar just for this site.
                    </li>
                </ul>
            </div>

            <h3>Source Control</h3>
            <div id="architecture-scm">
                <p>
                    <strong>Git</strong> along with <strong>Github</strong> makes a pretty ubiquitous choice. So far I've just used Git on the command line. It's simple and clean - especially for a one-man app like this one. Visit the Github repo at <a href="https://github.com/jsandoval81/ti" class="ui-link" target="_blank">github.com/jsandoval81/ti</a>.
                </p>
            </div>

            <h3>Unit Testing</h3>
            <div id="architecture-testing">
                <p>
                    I have to admit I’m still working on filling out <em>all</em> of the tests for this app. Up to this point I’ve been using <strong>Mocha</strong> as my test framework with <strong>Chai</strong> as my assertion library (together with <strong>Chai-Things</strong>). I've started off with <strong>Sinon</strong> for stubs and mocks. I also have some front-end output tests that use <strong>PhantomJS</strong>. Right now it's a toss-up between creating a PhantomJS child process to interact with or using the mocha-phantomjs test runner.
                </p>

                <p>
                    I typically prefer the <strong>Behavior-Driven Development</strong> approach, though the libraries I've listed are extremely common and also support TDD. In the end, it takes a host of these libraries to test the full stack from Mongoose models, server functions, HTTP, and DOM. There are also some fringe libraries that I would like to incorporate in the future, such as Gremlins.js, which basically tries to rip a site apart.
                </p>

                <p>
                    I've seen quite a few folks have success with Karma for MEAN stack testing. I like the prospect of all the Karma browser packages. That will likely be integrated into my next project(s).
                </p>
            </div>

            <h3>Build and Dev Automation</h3>
            <div id="architecture-deploy">
                <p>
                    The list of production deployment tasks for any app can be quite daunting. Running and evaluating your unit tests, linting, combining and minifying your static assets, compression, copying, and all the other build tasks could take hours. Solutions like custom shell scripts can help with this, but sometimes you need better abstraction, integration, and extensibility. 
                </p>

                <p>
                    I've decided on <strong>Grunt.js</strong> for not only production build automation, but dev environment automation as well.
                </p>

                <p>
                    For production builds, I've gone with the Grunt <strong>-contrib-</strong> libraries, such as <strong>Clean, Copy, Concat, Minify, Uglify</strong>, etc. For dev environment automation I've employed the <strong>Watch, NodeMon, and Concurrent</strong> modules (in addition to the -contrib- modules). Whenever I edit my CSS or front-end scripts these utilities will automatically concat and minify/uglify my single .min assets. And when I modify my server-side Node.js files, nodemon will automatically restart my Node/Express server - and refresh the browser if I want. The watch module does all of this automatically on file save. File save can also be automated with free text editors like <strong>Sublime Text</strong>.

                <p>
                    With a small investment of time, we can eliminate most/all of the manual steps during development and production builds. This is a huge time saver which allows developers to focus on one thing: developing. 
                </p>
            </div>

        </div>
 
<% include about-footer %>